-- ============================================
-- MIGRATION 013: REFERENCE & DOCUMENT EMBEDDINGS
-- ============================================
-- Purpose: Add vector embeddings to references and generated_documents for semantic search
-- This enables unified research across all project knowledge sources

-- Ensure pgvector extension is enabled (should already be enabled from migration 009)
CREATE EXTENSION IF NOT EXISTS vector;

-- ============================================
-- 1. ADD EMBEDDING COLUMNS TO REFERENCES
-- ============================================

-- Add embedding column to references
-- Using 1536 dimensions for OpenAI text-embedding-3-small model
ALTER TABLE "references"
ADD COLUMN IF NOT EXISTS embedding vector(1536);

-- Add embedding metadata columns
ALTER TABLE "references"
ADD COLUMN IF NOT EXISTS embedding_model VARCHAR(100),
ADD COLUMN IF NOT EXISTS embedding_generated_at TIMESTAMP WITH TIME ZONE;

-- Create index for fast similarity search using cosine distance
CREATE INDEX IF NOT EXISTS references_embedding_idx
ON "references"
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Add comments explaining the embedding columns
COMMENT ON COLUMN "references".embedding IS
'Vector embedding (1536 dimensions) generated by OpenAI text-embedding-3-small model for semantic search across uploaded files and URLs';

COMMENT ON COLUMN "references".embedding_model IS
'Name of the embedding model used (e.g., text-embedding-3-small)';

COMMENT ON COLUMN "references".embedding_generated_at IS
'Timestamp when the embedding was generated';

-- ============================================
-- 2. ADD EMBEDDING COLUMNS TO GENERATED_DOCUMENTS
-- ============================================

-- Add embedding column to generated_documents
ALTER TABLE generated_documents
ADD COLUMN IF NOT EXISTS embedding vector(1536);

-- Add embedding metadata columns
ALTER TABLE generated_documents
ADD COLUMN IF NOT EXISTS embedding_model VARCHAR(100),
ADD COLUMN IF NOT EXISTS embedding_generated_at TIMESTAMP WITH TIME ZONE;

-- Create index for fast similarity search using cosine distance
CREATE INDEX IF NOT EXISTS generated_documents_embedding_idx
ON generated_documents
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Add comments
COMMENT ON COLUMN generated_documents.embedding IS
'Vector embedding (1536 dimensions) generated by OpenAI text-embedding-3-small model for semantic search across AI-generated project documents';

COMMENT ON COLUMN generated_documents.embedding_model IS
'Name of the embedding model used (e.g., text-embedding-3-small)';

COMMENT ON COLUMN generated_documents.embedding_generated_at IS
'Timestamp when the embedding was generated';

-- ============================================
-- 3. CREATE UNIFIED SEMANTIC SEARCH FUNCTION
-- ============================================

-- Search across both references and generated_documents using semantic similarity
CREATE OR REPLACE FUNCTION search_semantic_similarity(
  query_embedding vector(1536),
  project_id_filter UUID,
  similarity_threshold FLOAT DEFAULT 0.7,
  max_results INT DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  type TEXT,
  filename TEXT,
  content TEXT,
  similarity FLOAT
) AS $$
BEGIN
  RETURN QUERY

  -- Combine results from both references and generated_documents
  WITH combined_results AS (
    -- Search references
    SELECT
      r.id,
      'reference'::TEXT as type,
      COALESCE(r.filename, 'Untitled Reference') as filename,
      COALESCE(
        r.metadata->>'extractedContent',
        r.metadata->>'analysis',
        ''
      ) as content,
      1 - (r.embedding <=> query_embedding) AS similarity
    FROM "references" r
    WHERE
      r.project_id = project_id_filter
      AND r.embedding IS NOT NULL
      AND 1 - (r.embedding <=> query_embedding) >= similarity_threshold

    UNION ALL

    -- Search generated_documents
    SELECT
      g.id,
      'generated_document'::TEXT as type,
      g.title as filename,
      g.content,
      1 - (g.embedding <=> query_embedding) AS similarity
    FROM generated_documents g
    WHERE
      g.project_id = project_id_filter
      AND g.embedding IS NOT NULL
      AND 1 - (g.embedding <=> query_embedding) >= similarity_threshold
  )

  -- Order by similarity and limit results
  SELECT
    cr.id,
    cr.type,
    cr.filename,
    cr.content,
    cr.similarity
  FROM combined_results cr
  ORDER BY cr.similarity DESC
  LIMIT max_results;
END;
$$ LANGUAGE plpgsql;

-- Add comment explaining the function
COMMENT ON FUNCTION search_semantic_similarity IS
'Unified semantic search across both references and generated_documents. Returns top matches ordered by similarity score.';

-- ============================================
-- 4. CREATE HELPER FUNCTIONS FOR INDIVIDUAL TABLES
-- ============================================

-- Search only references
CREATE OR REPLACE FUNCTION search_similar_references(
  query_embedding vector(1536),
  project_id_filter UUID,
  similarity_threshold FLOAT DEFAULT 0.7,
  max_results INT DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  filename TEXT,
  url TEXT,
  content TEXT,
  similarity FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    r.id,
    COALESCE(r.filename, 'Untitled Reference') as filename,
    -- Use file_url column (actual column name in schema)
    r.file_url as url,
    COALESCE(
      r.metadata->>'extractedContent',
      r.metadata->>'analysis',
      ''
    ) as content,
    1 - (r.embedding <=> query_embedding) AS similarity
  FROM "references" r
  WHERE
    r.project_id = project_id_filter
    AND r.embedding IS NOT NULL
    AND 1 - (r.embedding <=> query_embedding) >= similarity_threshold
  ORDER BY r.embedding <=> query_embedding
  LIMIT max_results;
END;
$$ LANGUAGE plpgsql;

-- Search only generated_documents
CREATE OR REPLACE FUNCTION search_similar_documents(
  query_embedding vector(1536),
  project_id_filter UUID,
  similarity_threshold FLOAT DEFAULT 0.7,
  max_results INT DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  title TEXT,
  document_type VARCHAR(50),
  content TEXT,
  similarity FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    g.id,
    g.title,
    g.document_type,
    g.content,
    1 - (g.embedding <=> query_embedding) AS similarity
  FROM generated_documents g
  WHERE
    g.project_id = project_id_filter
    AND g.embedding IS NOT NULL
    AND 1 - (g.embedding <=> query_embedding) >= similarity_threshold
  ORDER BY g.embedding <=> query_embedding
  LIMIT max_results;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- 5. CREATE FUNCTION TO COUNT MISSING EMBEDDINGS
-- ============================================

-- Count how many references/documents need embeddings generated
CREATE OR REPLACE FUNCTION count_missing_embeddings(
  project_id_filter UUID
)
RETURNS TABLE (
  references_without_embeddings BIGINT,
  documents_without_embeddings BIGINT,
  total_missing BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    (SELECT COUNT(*) FROM "references" WHERE project_id = project_id_filter AND embedding IS NULL) as references_without_embeddings,
    (SELECT COUNT(*) FROM generated_documents WHERE project_id = project_id_filter AND embedding IS NULL) as documents_without_embeddings,
    (SELECT COUNT(*) FROM "references" WHERE project_id = project_id_filter AND embedding IS NULL) +
    (SELECT COUNT(*) FROM generated_documents WHERE project_id = project_id_filter AND embedding IS NULL) as total_missing;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- MIGRATION NOTES
-- ============================================

-- This migration:
-- 1. Adds embedding columns to "references" and generated_documents tables
-- 2. Creates indexes for fast vector similarity search
-- 3. Provides unified search function across both tables
-- 4. Uses file_url column (actual schema column name)

-- After running this migration:
-- 1. Embeddings will be generated automatically for NEW references and documents
-- 2. Use the backfill script to generate embeddings for EXISTING data:
--    npx ts-node backend/src/scripts/backfillEmbeddings.ts <projectId>

-- Performance notes:
-- - IVFFlat index with lists=100 is optimal for ~10,000 vectors
-- - If you have significantly more references, increase lists parameter
-- - Embeddings are generated asynchronously to avoid blocking uploads
